백준 4489번 

안정적인 문자열

시간제한 
1 초

메모리 제한 
128 MB	

문제

여는 괄호와 닫는 괄호만으로 이루어진 문자열이 주어진다. 여기서 안정적인 문자열을 만들기 위한 최소 연산의 수를 구하려고 한다. 안정적인 문자열의 정의란 다음과 같다.

빈 문자열은 안정적이다.

S가 안정적이라면, {S}도 안정적인 문자열이다.

S와 T가 안정적이라면, ST(두 문자열의 연결)도 안정적이다.

{}, {}{}, {{}{}}는 안정적인 문자열이지만, }{, {{}{, {}{는 안정적인 문자열이 아니다.

문자열에 행할 수 있는 연산은 여는 괄호를 닫는 괄호로 바꾸거나, 닫는 괄호를 여는 괄호로 바꾸는 것 2가지이다.

입력

입력은 여러 개의 데이터 세트로 이루어져 있다. 각 데이터 세트는 한 줄로 이루어져 있다. 줄에는 여는 괄호와 닫는 괄호만으로 이루어진 문자열이 주어진다. 문자열의 길이가 2000을 넘는 경우는 없고, 항상 길이는 짝수이다.

입력의 마지막 줄은 '-'가 한 개 이상 주어진다.

출력

각 테스트 케이스에 대해서, 테스트 케이스 번호와 입력으로 주어진 문자열을 안정적으로 바꾸는데 필요한 최소 연산의 수를 출력한다.

풀이 

첫 접근은 스트링으로 해서 하나하나 대조해보는 접근을 생각해보다가 하나하나 접근하는 것은 벡터가 편하다 판단함 
벡터로 진행하면서 처음에는 { }의 갯수를 세어가면서 둘중에 큰 것 빼기 전체 갯수의 반으로 나눈것을 계산해서 출력하고 만약 둘이가 같다면 0을 출력하는 프로그램을 만들었음 

#include <iostream>
#include <algorithm>
using namespace std;

int main(){
    char c;
    int inner,outter,i = 1;
    int result = 0;
    while(true){
        cin >> c;
        if(c=='{'){
            inner++;
        }
        else if( c == '}'){
            outter++;
        }
        else if(c=='-'){
            break;
        }
        if(c=='\n'){
            if(inner==outter){
                cout<<i<<". "<<"0\n";
                inner=0;
                outter=0;
                i++;
            }
            else{
                result=max(inner,outter)-(inner+outter)/2;
                cout<<i<<". "<<result<<'\n';
                inner=0;
                outter=0;
            }
        }
    
        
        
        
    }
        return 0;
}

하지만 이 코드의 치명적인 문제점은 }{을 0으로 판단한다는 문제임
이 문제를 겪고 어떤 접근이 좋을까 생각하다가 스택느낌의 접근은 어떨지 생각해보게됨 
예를 들어 { 를 입력하면 벡터에 넣어주고 }를 입력하면 벡터에서 빼주는 프로그램 
}를 입력했을 때 거기에 만약 벡터가 비어있다면 결과에 +1을 해주고
입력이 완료되면 엔터를 쳐서 
마지막에 벡터 사이즈를 구해서 
