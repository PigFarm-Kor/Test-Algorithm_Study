1.배열(Array)
메모리 상에 원소를 연속하게 배치한 자료구조

배열의 성질 
1. O(1)에 k번째 원소를 확인/변경 가능 -> 인덱싱 
2. 오버헤드가 거의 없음 -> 크기가 정해져있기 때문에
3. 캐시 히트 레이트가 높음
4. 메모리 상에서 연속한 구간을 잡아야하기에 할당에 제약

우리가 만약 배열 안에 원소를 확인하거나 변경하고싶으면 바로 인덱싱 하면 됨 

예를 들어 3번째 원소를 확인하거나 변경하고싶으면 
arr[2]; 프린트해서 내용을 O(1)에 확인 가능하고
int temp = arr[2];
arr[2] = 3;
이런식으로 내용 변경도 O(1)에 가능하다.

원소 끝에 데이터를 추가하고싶으면 
arr[end-1] = k;
이런식으로 O(1)애 추가가 가능하고 

원소 끝에 데이터를 삭제하고싶으면 
끝부분만 지우면 되므로 O(1)로 삭제가 가능하다

하지만 만약 맨 끝이 아닌 다른 인덱스에 원소를 추가하고싶다면 
추가하는 순간 뒤에있는 모든 원소들을 한칸씩 뒤로 옮겨서 자리를 만든다음 넣어야한다. 
가장 최악의 경우는 0번 인덱스에 값을 추가해서 모든 원소들을 한칸씩 뒤로 옮겨야하므로 
시간복잡도는 O(N)이 된다

또 맨 끝이 아닌 다른 인덱스에 원소를 제거하는 것도 O(N)이 된다.
왜냐하면 중간에 한칸을 비우게 되면 다른 원소들이 한칸씩 앞으로 와야하고 
이때 최악의 경우는 맨 앞의 원소를 삭제하는 경우이기 때문에 O(N)이 된다

정리하자면 

임의의 위치의 원소를 확인/변경할 때 O(1)
맨 뒤에 원소를 하나 추가할 때 O(1)
맨 뒤에 있는 원소를 제거할 때O(1)
맨뒤가 아닌 다른 위치에 원소를 추가하거나 제거할 때 O(N)

기능 구현 

#include <bits/stdc++.h>
using namespace std;

void insert(int idx, int num, int arr[], int& len){
  for(int i = len - 1 ; i >= idx; i--){
    arr[i+1] = arr[i];
  }
  arr[idx]=num;
  len++:
}
//배열의 다음 칸에 전 값을 대입해서 한칸씩 밀어내고 idx자리에 내가 원하는 값 대입
//for문이 한번 사용되어서 O(N)의 시간복잡도를 가짐

void erase(int idx, int arr[], int& len){
  for(int i = idx; i < len; i++){
    arr[i]==arr[i+1];
  }
  len--;
}
//내가 삭제하고싶은 인덱스의 다음값을 내가 삭제하고싶은 인덱스에 대입 => 값 삭제
//그 후에 똑같은 방법으로 한칸씩 당기고 맨 뒤에있는 값을 삭제 (실질적인 코드로 삭제는 다른 메서드를 사용해야해서 길이만 줄임)
//for문 한번 사용-> O(N)의 시간복잡도를 가짐

배열 활용 팁 

안에 모든 값을 같은걸로 초기화 하고싶을 때 

1. for문 
너무 당연해서 넘어감
2. fill
algorithm헤더에 있는 함수 

fill(a,a+21,0);
이런식으로 사용 가능 

2. Vector 

vector는 배열과 거의 동일한 기능을 수행하는 자료구조
배열과 마찬가지로 원소가 메모리에 연속하게 저장되어 있기 때문에 O(1)에 인덱스를 가지고 각 원소로 접근 가능
vector는 배열과 달리 크기를 자유자재로 늘이거나 줄일 수 있다는 장점이 있음

vector도 insert와 erase의 시간 복잡도는 O(N)이고 이미 메서드로 구현이 되어있음
push_back, pop_back은 맨 뒤에 추가 삭제이므로 O(1)의 시간복잡도를 가짐 

vector끼리 =(대입) 연산을 했을 때 deep copy(주소 공유 X) 발생하기 때문에 조심해야함

vector를 순회하는 방법은 for문으로 v.size()까지 연산을 진행해도 되지만 
for(int n:v) 이런식으로도 가능함 (range-based for loop)

주의할 점은 v.size()는 연산을 잘못하면 안된다는 것 ->size 매서드는 uint를 반환하기 때문에 값이 이상해질수있음 
